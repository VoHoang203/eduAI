import { prisma } from '@/db/prisma';
import { validateRequest } from '@/auth';
import { NextResponse } from 'next/server';

import { Mux } from '@mux/mux-node';
const mux = new Mux({
  tokenId: process.env.MUX_TOKEN_ID!,
  tokenSecret: process.env.MUX_TOKEN_SECRET!,
});

export async function PATCH(
  req: Request,
  { params }: { params: { courseId: string; chapterId: string } },
) {
  try {
    const { user } = await validateRequest();
    const { courseId, chapterId } = await params;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { isPublished, ...values } = await req.json();

    if (!user) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    const courseOwner = await prisma.course.findUnique({
      where: {
        id: courseId,
        userId: user.id,
      },
    });

    if (!courseOwner) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    const chapter = await prisma.chapter.update({
      where: {
        id: chapterId,
        courseId: courseId,
      },
      data: {
        ...values,
      },
    });

    /*  
            If the values contain videoUrl (a patch req came from chapter-video-form.tsx)
            then proceed to process the video in the database and in the MUX
        */
    if (values.videoUrl) {
      /*  
                Find if the chapter already have an uploaded video in the database
                by checking if the id of the chapter (chapterId) matched a certain
                muxData in the database. If so, delete the existingMuxData on MUX 
                and in the database
            */
      const existingMuxData = await prisma.muxData.findFirst({
        where: {
          chapterId: chapterId,
        },
      });

      if (existingMuxData) {
        await mux.video.assets.delete(existingMuxData.assetId);
        await prisma.muxData.delete({
          where: {
            id: existingMuxData.id,
          },
        });
      }

      /*  
                Start to upload the videoUrl of the chapter (generated by the UploadThing)
                into MUX
            */
      // @ts-expect-error: Mux type mismatch, still works at runtime
      const asset = await mux.video.assets.create({
        input: values.videoUrl,
        playback_policies: ['public'],
        test: false,
      });

      /*  
                Once the upload of videoUrl of the chapter into MUX has finished proceed
                in storing the muxData into the database
            */
      await prisma.muxData.create({
        data: {
          chapterId: chapterId,
          assetId: asset.id,
          playbackId: asset.playback_ids?.[0]?.id,
        },
      });
    }

    return NextResponse.json(chapter);
  } catch (error) {
    console.log('[COURSES_CHAPTER_ID]', error);
    return new NextResponse('Internal Error', { status: 500 });
  }
}

export async function DELETE(
  req: Request,
  { params }: { params: { courseId: string; chapterId: string } },
) {
  try {
    const { user } = await validateRequest();
    const { courseId, chapterId } = await params;
    /* 
			Check if there's a logged in user (authentication)
		*/
    if (!user) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    /* 
			Check if the user deleting a chapter of a course
            is the owner of the course (authorization)
		*/
    const courseOwner = await prisma.course.findUnique({
      where: {
        id: courseId,
        userId: user.id,
      },
    });

    if (!courseOwner) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    /* 
			Check if the chapter the user is attempting to delete
            exist in the database, if not return 404 not found
		*/
    const chapter = await prisma.chapter.findUnique({
      where: {
        id: chapterId,
        courseId: courseId,
      },
    });

    if (!chapter) {
      return new NextResponse('Not Found', { status: 404 });
    }

    /* 
			At this point the user is authenticated, authorized and the chapter
            that is going to be deleted really exist. Next, is to find out if the
            chapter has a videoUrl data. If so, delete the video on MUX and into
            the MuxData table
		*/
    if (chapter.videoUrl) {
      /* 
                First, find if such chapter exist in the MuxData table
		    */
      const existingMuxData = await prisma.muxData.findFirst({
        where: {
          chapterId: chapterId,
        },
      });

      /* 
                If so delete the video in MUX and the MuxData table
		    */
      if (existingMuxData) {
        await mux.video.assets.delete(existingMuxData.assetId);
        await prisma.muxData.delete({
          where: {
            id: existingMuxData.id,
          },
        });
      }
    }

    /* 
			Next, delete the chapter in the Chapter table
		*/
    const deletedChapter = await prisma.chapter.delete({
      where: {
        id: chapterId,
      },
    });

    /* 
			Since we only allow a course to be publishable if at least one
            of its chapters was published. We need to perform a check.  
            By deleting a chapter, it's possible that a course will no  
            longer have at least one chapter where isPublished set to true. 
            In this case we want to make the course's isPublished set 
            back to false. Here, we are checking how many chapters are in a
            certain course where isPublished is true. If `publishedChaptersInCourse`
            length value is 0 we are going to update the course's isPublished
            value to false
		*/
    const publishedChaptersInCourse = await prisma.chapter.findMany({
      where: {
        courseId: courseId,
        isPublished: true,
      },
    });

    if (!publishedChaptersInCourse.length) {
      await prisma.course.update({
        where: {
          id: courseId,
        },
        data: {
          isPublished: false,
        },
      });
    }

    return NextResponse.json(deletedChapter);
  } catch (error) {
    console.log('[CHAPTER_ID_DELETE]', error);
    return new NextResponse('Internal Error', { status: 500 });
  }
}
